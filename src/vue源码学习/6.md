---
title: 六、实现Reactive和Effect函数
icon: laptop-code
order: 6
category:
  - 使用指南
---

## 概述

通过 Proxy 代理对象，在 getter 中的 Track 函数构建 TargetMap 收集 key 与 effect 中接受函数的对应关系，在 setter 中的 Trigger 执行 effect 接受的函数

![](/assets/images/reactive.drawio.png)

## 基本 Reactive 函数

> reactive.ts

```js
export const reactiveMap = new WeakMap<object,any>()

export function reactive(target:Object){
    /**
     * target-原对象
     * mutableHandlers：对set、get等的定义
     * reactiveMap:WeakMap类型，保存所有的Proxy对象
     */
    return createReactiveObject(target,mutableHandlers,reactiveMap)
}

function createReactiveObject(target:Object,baseHandlers:ProxyHandler<any>,proxyMap:WeakMap<object,any>)
{
    const existingProxy = proxyMap.get(target)
    // 如果已经建立过proxy就直接返回
    if(existingProxy){
        return existingProxy
    }
    // 没建立过就创建一个Proxy保存在proxyMap中
    const proxy = new Proxy(target,baseHandlers)
    proxyMap.set(target,proxy)
    return proxy
}
```

> baseHanlders.ts 定义 Proxy 的 get 和 set

```js
import { track, trigger } from "./effect";

function createGetter() {
  return function get(target: object, key: string | symbol, receiver: object) {
    // 通过Reflect来返回值，保证this绑定在receiver上
    const res = Reflect.get(target, key, receiver);
    console.log("track");
    // 通过track收集依赖
    track(target, key);
    return res;
  };
}

function createSetter() {
  return function get(
    target: object,
    key: string | symbol,
    value: unknown,
    receiver: object
  ) {
    const res = Reflect.set(target, key, value, receiver);
    console.log("trigger");
    // 通过trigger触发
    trigger(target, key, value);
    return res;
  };
}

const get = createGetter();
const set = createSetter();

export const mutableHandlers: ProxyHandler<object> = {
  get,
  set,
};
```

## 基本 Effect 函数

```ts
// activeEffect表示当前正在执行的effect函数对应的ReactiveEffect对象
export let activeEffect: ReactiveEffect | undefined;

// 创建一个ReactiveEffec类，其有一个公共成员fn，该函数时effect接受的函数；还有一个run方法，会执行fn函数，并将this赋给activeEffect
export class ReactiveEffect<T = any> {
  // ts中成员默认为public，在构造函数的参数上使用public等同于创建了同名的成员变量
  constructor(public fn: () => T) {}
  run() {
    activeEffect = this;
    return this.fn();
  }
}

export function effect<T = any>(fn: () => T) {
  const _effect = new ReactiveEffect(fn);
  _effect.run();
  // 等函数运行结束后，依赖已经收集完毕，此时置空activeEffect防止被不相关的key收集
  activeEffect = null;
}
```

## getter 中的 Track 函数

targetMap 为一个 Weakmap 类型的数据，第一层的 key 为 target，value 为 Map 类型，其 key 为 get 函数接受的 key，value 是一个 set 类型，用于保存多个 effect 函数创建的 `ReactiveEffect` 对象

![TargetMap的数据结构](/assets/images/targetMap.png)

```ts
export type Dep = Set<ReactiveEffect>;

// ?表示不一定存在 创建set
export const createDep = (effects?: ReactiveEffect[]): Dep => {
  return new Set<ReactiveEffect>(effects);
};

type KeyToDepMap = Map<any, Dep>;
const targetMap = new WeakMap<any, KeyToDepMap>();

export function track(target: object, key: unknown) {
  // 如果没有任何effect函数执行，就退出
  if (!activeEffect) return;
  let depsMap = targetMap.get(target);
  //如果没有depsMap就创建一个
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }
  let dep = depsMap.get(key);
  // 如果dep已经添加了这个activeEffect，就退出
  if (dep?.has(activeEffect)) {
    return;
  }
  //  如果没有dep就创建一个
  if (!dep) {
    depsMap.set(key, (dep = createDep()));
  }
  //
  trackEffects(dep);
}

export function trackEffects(deps: Dep) {
  // !表示非空断崖可以排除undefined和null，当函数能执行到此处，activeEffect一定存在
  deps.add(activeEffect!);
}
```

## setter 中的 Trigger 函数

```ts
export function trigger(target: object, key: unknown, newvalue: unknown) {
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  const dep: Dep | undefined = depsMap.get(key);

  if (!dep) {
    return;
  }

  triggerEffects(dep);
}

export function triggerEffects(dep: Dep) {
  const effects = Array.isArray(dep) ? dep : [...dep];
  for (const effect of effects) {
    effect.run();
  }
}
```

## reactive 的局限性

1. **有限的类型**：proxy 只能对对象进行代理，因此 reactvie 只适用于有限的值类型：它只能用于 ==对象类型== (对象、数组和如 Map、Set 这样的集合类型)。它不能持有如 string、number 或 boolean 这样的 ==原始类型==

2. **对解构操作不友好**：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接(因为解构出的数据不再是 Proxy 类型)

3. **不能替换整个对象**：由于 Vue 的响应式跟踪是通过 ==属性访问== 实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失：

```js
let state = reactive({ count: 0 });

// 上面的 ({ count: 0 }) 引用将不再被追踪
// (响应性连接已丢失！)
state = reactive({ count: 1 });
```
