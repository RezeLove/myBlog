---
title: 一、vue概述
icon: laptop-code
order: 1
category:
  - 使用指南
  - vue
---

## 虚拟 DOM

虚拟 DOM: 用 JavaScript 对象描述 UI 的方式

目的：让用户可以声明式地去构建 UI，相较于调用 DOM api 命令式代码，可维护性更高，心智负担低；虽然性能不如命令式代码，但可以通过 Diff 算法找出虚拟 DOM 变化的地方（javascript 层面的运算，消耗远小于 DOM 层面的计算），再进行必须要的 DOM 更新，避免全量更新，提高性能。

优点：

1. 提高开发效率：能够基于函数式 UI 的编程方式实现高效的声明式编程
2. 跨平台问题：虚拟 DOM 是对真实渲染内容的一层抽象。同一套虚拟 DOM，可以对接不同平台的渲染逻辑(可以将 DOM 操作抽离出来)，从而实现“一次编码，多端运行”

## 运行时/编译时

1. 纯运行时框架

假设我们设计了一个框架，它提供一个 Render 函数，用户可以为该函数提供一个树型结构的数据对象，然后 Render 函数会根据该对象递归地将数据渲染成 DOM 元素。用户在使用时，直接为 Render 函数提供了一个树型结构的数据对象，但手写树形结构不够直观（缺点）

```js
const obj = {
  tag: "div",
  children: [{ tag: "span", children: "hello world" }],
};
// 渲染到 body 下
Render(obj, document.body);
```

2. 纯编译时框架

通过 Compiler 函数将 HTML 字符串编译为命令式代码（如 DOM api）这就变成了一个纯编译时的框架，因为不支持任何运行时内容，用户的代码通过编译器编译后
才能运行

3. 运行时+编译时

既支持运行时，用户可以直接提供数据对象从而无须编译；又支持编译时，用户可以提供 HTML 字符串，我们将其编译为数据对象后再交给运行时处理。

准确地说，上面的代码其实是运行时编译，意思是代码运行的时候才开始编译，而这会产生一定的性能开销，因此我们也可以在构建的时候就执行 Compiler 程序将
用户提供的内容编译好，等到运行时就无须编译了，这对性能是非常友好的

4. 比较

纯运行时框架没办法分析用户提供的内容，但是如果加入编译步骤，可能就大不一样了，我们可以分析用户提供的内容，看看哪些内容未来可能会改变，哪些内容永远不会改变，这样我们就可以在编译的时候提取这些信息，然后将其传递给 Render 函数，Render 函数得到这些信息之后，就可以做进一步的优化了

纯编译时框架有损灵活性（比如一个多层 v-if v-else）用户提供的内容必须编译后才能用
