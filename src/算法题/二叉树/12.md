---
title: 二叉树的最近公共祖先
order: 12
category:
  - 算法题
  - 二叉树
---

## 题目链接

[题目链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

## 思路

由于是找公共祖先，因此从下向上找比较合适，采用后序遍历比较合适
公共祖先存在两种情况：

1. p 或 q 分别在 left 和 right
2. p 是 q 的子节点或 q 是 p 的子节点

![公共祖先的2种情况](/assets/images/ggzx2.jpg)

1. 后序遍历，找到 p 或 q 就返回，没找到就返回 null
2. 当 left 找到了对应的 p 或 q，right 没找到，就返回 left 的值，反之亦然
3. 如果一个 root 的左右节点都找到了值，那么该结点就是 p 和 q 的公共祖先

![递归流程](/assets/images/ggzx1.jpg)

## 实现

```js
var lowestCommonAncestor = function (root, p, q) {
  const travelTree = function (root, p, q) {
    // 递归终止条件，包含了情况2，如果p是q的子节点，那么遇到q之后就不会继续递归
    if (root == p || root == q || root == null) {
      return root;
    }
    // 后序遍历，取到当前节点下left和right值
    let left = travelTree(root.left, p, q);
    let right = travelTree(root.right, p, q);

    // 传递上来的的left和right都找到了值，说明root就是公共节点
    if (left !== null && right !== null) {
      return root;
    }
    // 如果left传上来的是null，则返回right的值
    if (!left) {
      return right;
    }
    // 反之
    return left;
  };
  return travelTree(root, p, q);
};
```
