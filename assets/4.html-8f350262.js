const e=JSON.parse('{"key":"v-684ad922","path":"/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/js/4.html","title":"ES6与CommonJS模块化的区别","lang":"zh-CN","frontmatter":{"title":"ES6与CommonJS模块化的区别","order":4,"category":["面试"],"description":"模块化 模块化的目的： 代码抽象 代码封装 代码复用 依赖管理 如果不进行模块化，变量和方法不容易维护，容易污染全局作用域；依赖的环境主观逻辑偏重，代码较多就会比较复杂。 CommonJS 模块化方法 CommonJS 是一套 Javascript 模块规范，用于服务端,定义一个模块导出通过 exports 或者 module.exports 挂载即可 CommonJS 具有如下特点： 所有代码都运行在模块作用域，不会污染全局作用域 模块是同步加载的，即只有加载完成，才能执行后面的操作 模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存 require 返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/js/4.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"ES6与CommonJS模块化的区别"}],["meta",{"property":"og:description","content":"模块化 模块化的目的： 代码抽象 代码封装 代码复用 依赖管理 如果不进行模块化，变量和方法不容易维护，容易污染全局作用域；依赖的环境主观逻辑偏重，代码较多就会比较复杂。 CommonJS 模块化方法 CommonJS 是一套 Javascript 模块规范，用于服务端,定义一个模块导出通过 exports 或者 module.exports 挂载即可 CommonJS 具有如下特点： 所有代码都运行在模块作用域，不会污染全局作用域 模块是同步加载的，即只有加载完成，才能执行后面的操作 模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存 require 返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-21T08:05:49.000Z"}],["meta",{"property":"article:author","content":"TX"}],["meta",{"property":"article:modified_time","content":"2024-01-21T08:05:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ES6与CommonJS模块化的区别\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-01-21T08:05:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"TX\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"模块化","slug":"模块化","link":"#模块化","children":[]},{"level":2,"title":"CommonJS 模块化方法","slug":"commonjs-模块化方法","link":"#commonjs-模块化方法","children":[]},{"level":2,"title":"ES6 模块化方法","slug":"es6-模块化方法","link":"#es6-模块化方法","children":[]}],"git":{"createdTime":1705824349000,"updatedTime":1705824349000,"contributors":[{"name":"RezeLove","email":"1224745953@qq.com","commits":1}]},"readingTime":{"minutes":1.46,"words":437},"filePathRelative":"前端笔记/js/4.md","localizedDate":"2024年1月21日","excerpt":"<h2> 模块化</h2>\\n<p>模块化的目的：</p>\\n<ul>\\n<li>代码抽象</li>\\n<li>代码封装</li>\\n<li>代码复用</li>\\n<li>依赖管理</li>\\n</ul>\\n<p>如果不进行模块化，变量和方法不容易维护，容易污染全局作用域；依赖的环境主观逻辑偏重，代码较多就会比较复杂。</p>\\n<h2> CommonJS 模块化方法</h2>\\n<p>CommonJS 是一套 Javascript 模块规范，用于服务端,定义一个模块导出通过 exports 或者 module.exports 挂载即可\\nCommonJS 具有如下特点：</p>\\n<ul>\\n<li>所有代码都运行在模块作用域，不会污染全局作用域</li>\\n<li>模块是同步加载的，即只有加载完成，才能执行后面的操作</li>\\n<li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li>\\n<li>require 返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值</li>\\n</ul>","autoDesc":true}');export{e as data};
