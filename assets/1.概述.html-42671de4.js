import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,f as p}from"./app-56460a49.js";const t={},e=p(`<h2 id="虚拟-dom" tabindex="-1"><a class="header-anchor" href="#虚拟-dom" aria-hidden="true">#</a> 虚拟 DOM</h2><p>虚拟 DOM: 用 JavaScript 对象描述 UI 的方式</p><p>目的：让用户可以声明式地去构建 UI，相较于调用 DOM api 命令式代码，可维护性更高，心智负担低；虽然性能不如命令式代码，但可以通过 Diff 算法找出虚拟 DOM 变化的地方（javascript 层面的运算，消耗远小于 DOM 层面的计算），再进行必须要的 DOM 更新，避免全量更新，提高性能。</p><p>优点：</p><ol><li>提高开发效率：能够基于函数式 UI 的编程方式实现高效的声明式编程</li><li>跨平台问题：虚拟 DOM 是对真实渲染内容的一层抽象。同一套虚拟 DOM，可以对接不同平台的渲染逻辑(可以将 DOM 操作抽离出来)，从而实现“一次编码，多端运行”</li></ol><h2 id="运行时-编译时" tabindex="-1"><a class="header-anchor" href="#运行时-编译时" aria-hidden="true">#</a> 运行时/编译时</h2><ol><li>纯运行时框架</li></ol><p>假设我们设计了一个框架，它提供一个 Render 函数，用户可以为该函数提供一个树型结构的数据对象，然后 Render 函数会根据该对象递归地将数据渲染成 DOM 元素。用户在使用时，直接为 Render 函数提供了一个树型结构的数据对象，但手写树形结构不够直观（缺点）</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&quot;span&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">&quot;hello world&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 渲染到 body 下</span>
<span class="token function">Render</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>纯编译时框架</li></ol><p>通过 Compiler 函数将 HTML 字符串编译为命令式代码（如 DOM api）这就变成了一个纯编译时的框架，因为不支持任何运行时内容，用户的代码通过编译器编译后 才能运行</p><ol start="3"><li>运行时+编译时</li></ol><p>既支持运行时，用户可以直接提供数据对象从而无须编译；又支持编译时，用户可以提供 HTML 字符串，我们将其编译为数据对象后再交给运行时处理。</p><p>准确地说，上面的代码其实是运行时编译，意思是代码运行的时候才开始编译，而这会产生一定的性能开销，因此我们也可以在构建的时候就执行 Compiler 程序将 用户提供的内容编译好，等到运行时就无须编译了，这对性能是非常友好的</p><ol start="4"><li>比较</li></ol><p>纯运行时框架没办法分析用户提供的内容，但是如果加入编译步骤，可能就大不一样了，我们可以分析用户提供的内容，看看哪些内容未来可能会改变，哪些内容永远不会改变，这样我们就可以在编译的时候提取这些信息，然后将其传递给 Render 函数，Render 函数得到这些信息之后，就可以做进一步的优化了</p><p>纯编译时框架有损灵活性（比如一个多层 v-if v-else）用户提供的内容必须编译后才能用</p>`,17),o=[e];function l(i,r){return a(),s("div",null,o)}const d=n(t,[["render",l],["__file","1.概述.html.vue"]]);export{d as default};
